class Solution {
    /**
    TC DFS IS O(V + E)
    SC O(V) - 2 1-d array used
     */
    public List<Integer> eventualSafeNodes(int[][] graph) {
        int N = graph.length;
        List<List<Integer>> adj = new ArrayList();

        for(int i = 0 ; i<N ; i++)
        {
            adj.add(new ArrayList());
        }

        for(int i = 0 ; i<N ; i++)
        {
            for(int j = 0 ; j < graph[i].length;j++)
            {
                adj.get(i).add(graph[i][j]);
            }
        }
        int visited[] = new int[N];
        int pathvisited[] = new int[N];

        for(int i = 0 ; i<N ; i++)
        {
            if(visited[i] == 0)
            {
                dfs(visited,pathvisited,adj,i);
            }
        }
        List<Integer>  ans = new ArrayList();
        for(int i = 0 ; i<N ; i++)
        {
            if(pathvisited[i] == 0)
            {
                ans.add(i);
            }
        }
        return ans;        
    }

    private boolean dfs(int visited[],int pathvisited[], List<List<Integer>> adj , int node )
    {
        visited[node] = 1;
        pathvisited[node] = 1;

        for(int it : adj.get(node))
        {
            if(visited[it] == 0)
            {
                if(dfs(visited,pathvisited,adj,it))
                    return true;
            }
            else if(pathvisited[it] == 1)
            {
                //in case of a cycle pathvisited will be 1 
                //found a cycle
                return true;

            }
        }
        //back track 
        pathvisited[node] = 0;
        return false;

    }
}