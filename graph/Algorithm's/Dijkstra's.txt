class Solution
{
/**
Time Complexity: O((V+E)*logV) (where V and E represent the number of nodes and edges of the graph)

Each node is processed once in the priority queue and deletion and insertion operation takes O(logV) time making it overall O(V*logV) in the worst case.
For each vertex, all its edges are relaxed. This operation involves updating the priority queue, which takes O(logV) making it overall O(E*logV) for E edges in the worst case.
Space Complexity: O(V)

The priority queue will store distances to all nodes in worst case leading to O(V) space.
The distance array takes O(V) space.



**/
    
     public int[] dijkstra(int V, 
        ArrayList<ArrayList<ArrayList<Integer>>> adj, int S) {
        
        // Priority queue
        PriorityQueue<int[]> pq = new PriorityQueue<>( (a,b) -> {
            if(a[0] == b[0])
            {
                return a[1]-b[1];
            }
            else
                return a[0] - b[0];
        });
        
        // Distance array
        int[] dist = new int[V];
        Arrays.fill(dist, (int) 1e9);
        
        // Distance of source node from itself is 0
        dist[S] = 0;
        
        // Add the source node to the priority queue
        pq.add(new int[]{0, S});
        
        // Until the priority queue is empty
        while (!pq.isEmpty()) {
            
            // Get the tentative distance
            int dis = pq.peek()[0];
            
            // Get the node
            int node = pq.peek()[1];
            pq.poll();
            
            // Traverse all its neighbors
            for (ArrayList<Integer> it : adj.get(node)) {
                
                int adjNode = it.get(0); // node
                int edgeWt = it.get(1); // edge weight
                
                /* If the tentative distance to 
                reach adjacent node is smaller 
                than the known distance */
                if (dis + edgeWt < dist[adjNode]) {
                    
                    // Update the known distance
                    dist[adjNode] = dis + edgeWt;
                    
                    // Push the new pair in priority queue
                    pq.add(new int[]{dist[adjNode], adjNode});
                }
            }
        }
        
        // Return the result
        return dist;
    }

}
