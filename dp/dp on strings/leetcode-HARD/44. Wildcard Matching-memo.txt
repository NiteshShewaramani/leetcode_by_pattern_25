class Solution {
    /**
    Time Complexity: O(N*M), Where N is the length of string S1 and M is the length of string S2.
    There are N*M states therefore at max ‘N*M’ new problems will be solved.
    Space Complexity: O(N*M) + O(N+M), We are using a recursion stack space(O(N+M)) and a 2D array (O(N*M)).
     */
    private Boolean function(String s,String p,int i,int j,Boolean dp[][]){
        //base cases
        //both the strings are empty return true
        if(i<0 && j<0)
        return true;
        //pattern string is empty but the other string is not
        if(i>=0 && j<0)
        return false;

        //main string is empty but the pattern string is not empty
        if(i<0 && j>=0)
        {
            for(int k=j;k>=0;k--)
            {
                if(p.charAt(k)!='*')
                return false;
            }
            return true;
        }

        if(dp[i][j]!=null)
        return dp[i][j] ;
        //if they match or we get a ? mark reduce both of them
        if(s.charAt(i)==p.charAt(j) || p.charAt(j)=='?')
        {
            return dp[i][j] = function(s,p,i-1,j-1,dp);
        }

        //if we have * then we have 2 choice either to take or nottake 
        if(p.charAt(j)=='*')
        {
            /* Two options: either '*' represents an 
            empty string or it matches a character in S2*/ 
            return dp[i][j] = function(s,p,i,j-1,dp) || function(s,p,i-1,j,dp);
        }

        return dp[i][j] =false;


    }
    public boolean isMatch(String s, String p) {
        Boolean dp[][] = new Boolean[s.length()][p.length()];
        return function(s,p,s.length()-1,p.length()-1,dp);
    }
}